---
title: Win32 Window
URLslug: projects/project2
date: 21/1/2023
---

# Project: Win32 Window
I have used CMake with console applications before but not with GUI applications.

## CMake
This is a simple CMake project so I only have a single `cmake•CMakeLists.txt` file which is in the below code fence. The file consists of the usual CMake setup except I specify the `cmake•WIN32` property when calling the `cmake•add_executable` command. This makes `cmake•Window`a GUI executable instead of a console application. The entry point to the program will now be `C++•WinMain` or `C++•wWinMain` rather than `C++•main`.
While it is possible to create a window within a console application, which can be beneficial during development for error output and debugging. I opted to develop it as a GUI application and manage error output independently.

```cmake {numberLines, filePath:{path:'Win32-Window/CMakeLists.txt', link:'https://github.com/james-door/Win32-Window/blob/master/CMakeLists.txt'}}
cmake_minimum_required(VERSION 3.8)

project ("Window")
set(CMAKE_CXX_STANDARD 17)
add_executable(Window WIN32 "Window.cpp")

option(USE_UNICODE "Support Unicode." ON)
if(USE_UNICODE)
    target_compile_definitions(Window PUBLIC UNICODE)
    target_compile_definitions(Window public _UNICODE)
endif()
```
Additionally I create a CMake Option `cmake•USE_UNICODE`. When `cmake•USE_UNICODE` is `cmake•ON` we set two compiler definitions `cmake•UNICODE` and `cmake•_UNICODE`. These compiler definitions will set both the Windows API and C runtime respectively to map functions to their wide-character versions. When `cmake•USE_UNICODE` is `cmake•OFF` then the functions will be mapped to narrow character versions. I use the `cmake•PUBLIC` specifier when adding the compile definition to the executable, ensuring that it is applied when linking with the Windows API and C runtime.

### Running the Cmake
We need to use the Visual studio CMakePreset.json depending on how we want `BASH• cmake --build --preset <build directory>` alternatively we can just use Visual Studio.   

Depending on the generator used to build the 


## The Window

### Project setup
Given that I am only creating a window, I only require the `C++•Windows.h` header file, which is required for accessing a number of Windows' APIs. Furthermore, since I am only using the Win32 API, I define `C++•WIN32_LEAN_AND_MEAN`. This definition excludes a number unrequired APIs. To assist with error logging, I also include a C++ standard library, `C++•sstream`. 
```C++ {numberLines: 1, filePath:{path: 'Win32-Window/Window.cpp',link:'https://github.com/james-door/Win32-Window/blob/master/Window.cpp'}}
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <sstream>
```
In the [CMake](#CMake) section I don't explictly link any Win32 library files. Most C++ compilers that support Windows, including Clang++, MSVC, and GCC (when used for Windows development), are configured to automatically link against these standard Windows libraries.

### Debugging
The first step I took was handling any potential future run-time errors generated by the Win32 API. The API doesn't use C++ exceptions for run-time errors so we must manually check for them the using function `C++•FormatMessage`. 
To determine if an error has occured `C++` I created the preprocessor macro `C++•HANDLE_RETURN` which takes a Boolean indicating whether an error has occured. I use the predefiend macros `C++•__FILE__` and `C++•__LINE__` to also get the file and line the macro was called from. Given that it is no longer a console application we can't output debug information to console. Instead I log any errors in the string stream `C++•Win32ErrorLog`. Given that the langauge of the messages are English by default there is no need to use unicode for the error messages and I can use narrow version `C++•FormatMessageA`.
```C++ {numberLines: 7, filePath:{path: 'Win32-Window/Window.cpp',link:'https://github.com/james-door/Win32-Window/blob/master/Window.cpp'}}
#define HANDLE_RETURN(err) LogIfFailed(err, __FILE__, __LINE__)

std::stringstream Win32ErrorLog;

inline void LogIfFailed(bool err, const char* file, int line)
{
    if (err)
    {
        DWORD error = GetLastError();
        LPVOID lpMsgBuf;
        FormatMessageA(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            error,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPSTR)&lpMsgBuf,
            0, NULL);


        std::string message = "File: " + std::string(file) + "\n\nMessage: " + std::string((char*)lpMsgBuf) + "\n\nLine: " + std::to_string(line);
        LocalFree(lpMsgBuf);

        Win32ErrorLog << message;
    }
}
}
```
At the end of the appliction I then call `C++•displayErrorMessage`, which create an ASNI Windows dialog box with any error messages in it.
```C++ {numberLines:116, filePath:{path: 'Win32-Window/Window.cpp',link:'https://github.com/james-door/Win32-Window/blob/master/Window.cpp'}}
  if (!Win32ErrorLog.str().empty()) {
        displayErrorMessage("Win32 Errors:\n\n" + Win32ErrorLog.str());
    }
```
 In future I could also choose to log the the messages in a file in case the application never reaches `C++•displayErrorMessage`.


### Creating the window
To create the window I used the Win32 API.
Use WinMain However I could use wWinMain I lpCmdLine is a wide string (PWSTR)

### Window procedure

### Message 









in the CMake project given that they are autoatmically linked with all complient C++ compilers.


### Exit the window 

GetMessage(&windowMsg, NULL, 0, 0); given that WM_QUIT is a thread message we have to specify NULL rather than the window handle. 



